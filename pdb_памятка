 11 октября 2020 г.
==========================
Python. Отладка при помощи pdb
================================

Запускаем отладчик:
------------------------
python -m pdb script.py
python -m pdb manage.py runserver 8000
Либо в коде можно указать место откуда надо запускать отладчик:
-------------------------------------------------------------
import pdb; pdb.set_trace()
А post-mortem запускается так:
------------------------------------
import pdb; pdb.pm()
Для тех кто не знает что такое post-mortem,
то это режим в котором отладчик стартует сразу после необработанного исключения.
=================================================================================


Список команд отладчика
-----------------------
h(elp) - отладчик выведет список допустимых команд.
Выполните help <command> для того чтобы получить справку по конкретной команде;

q(uit), exit - выход из отладчика.

Общие команды
-------------
l(ist) [<first> [,<last>]] - печать исходного кода. Без передачи аргументов
выводится +5 сверху и +5 снизу строк кода.
Можно передать два аргумента "first" и "last" - номера строк диапазон которых надо выводить,
если передать только один аргумент, то произойдет вывод +5 сверху и +5 снизу строк относительно указанного номера строки;

p <expression>, pp <expression> - "print" и "pprint" соответственно;

a(rgs) - выводит аргументы функции;

whatis <arg> - выведет тип объекта;


Навигация по коду
-----------------
w(here) - выводит информаию о позиции в которой сейчас находитесь;

s(tep) - "step into", перейти во внутрь вызова объекта, если это возможно,
иначе перейти к следующей строке кода;

n(ext) - "step over" (перешагнуть), перейти к следующей строке кода;

unt(il) - перейти к следующей строке кода, но гарантировано чтобы номер строки был больше чем текущий.
Пример: если вы находитесь в конце тела цикла, но это не последняя итерация,
то вас не отправит в начало тела цикла, а выполнится весь цикл и отладчик встанет на следующей строке после цикла,
в отличии от next;

r(eturn) - завершить ("выйти из") текущую функцию;

u(p) - подняться на один стек-фрейм вверх;

d(own) - опуститься на один стек-фрейм вниз;

j(ump) <lineno> - перепрыгнуть на указанную строку кода не выполняя код находящийся между текущей позицией и указанной.
Исключение составляют циклы for и код в блоке finally (т.к. должен быть обязательно выполнен).
Также, вы можете перепрыгивать только внутри текущего фрейма (т.е. нижнего фрейма).
=====================================================================================================================================


Точки останова
---------------
При использовании листинга (команда "list") строки с брейкпоинтами помечаются префиксом "B":

(Pdb) b

Num Type         Disp Enb   Where

1   breakpoint   keep yes   at /home/adw0rd/work/project/manage.py:5

(Pdb) list

  1     #!/usr/bin/env python

  2  -> import os

  3     import sys

  4

  5 B   if __name__ == "__main__":

  6         os.environ.setdefault("DJANGO_SETTINGS_MODULE", "project.settings")

  7         from django.core.management import execute_from_command_line

  8         execute_from_command_line(sys.argv)

[EOF]


b(reak) ([<file>:]<lineno> | <function>) [<condition>] - установка и листинг брейкпоинтов.
Аргументы позволяют указать файл и номер строки или функцию, 
где исполнение кода должно остановиться,пример:

(Pdb) b 5
(Pdb) b my_function


Для просмотра текущих установленных брейпоинтов, используйте команду break без аргументов:
(Pdb) b

Num Type         Disp Enb   Where
1   breakpoint   keep yes   at /home/adw0rd/work/project/manage.py:5
2   breakpoint   keep yes   at /home/adw0rd/work/project/project/settings.py:10
3   breakpoint   keep yes   at /home/adw0rd/work/project/manage.py:15



# Брейкпоинт выполнится только если переменная "some_var" будет больше 42
(Pdb) b my_function, some_var > 42

condition <bpnumber> <str_condition> - добавляет к существующему брейкпоинту условие


tbreak - временный брекпоинт, после использования удаляется,
имеет одинаковый синтаксис с break;

ignore <bpnumber> <count> - игнорировать count-раз определенный брейкпоинт.
Если передать count равный нулю, то игнорирование сбросится;

c(ont(inue)) - продолжить (до первого брейкпоинта или до завершения работы программы);

disable <bpnumber> [<bpnumber> ...] и enable <bpnumber> [<bpnumber> ...] - первый деактивирует брейкпоинт,
но НЕ удаляет его из списка брейкпоинтов.
А второй снова активирует брейкпоинт

cl(ear) (<filename>:<lineno> | [<bpnumber>...]) - удаляет брейкпоинт(ы).
Если передать номер брейкопинта то удалится только он, 
если ничего не пердавать - удалятся все брейкпоинты.
Если передать путь и номер строки, то удалятся все брейкпоинты установленные в указанном месте;

commands [<bpnumber>] - написание дополнительных действий для брейкпоинта,
например вывод локальных переменных и т.п. Пример:

(Pdb) break

Num Type        Disp    Enb     Where

1   breakpoint  keep    yes     at .../script.py:2


(Pdb) commands 1
(com) p "DEBUG"
(com) pp locals()
(com) end

(Pdb) continue
# Тут идёт печать locals()


Для удаления необходимо снова запустить commands, но с пустым телом:
(Pdb) commands 1
(com) end
======================================================================================================
